import os
import json
from typing import Optional, Dict, Any, List

import pytz
import aiohttp
from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import CommandStart, Command
from aiogram.enums import ParseMode, ChatMemberStatus
from aiogram.utils.keyboard import InlineKeyboardBuilder
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
from dotenv import load_dotenv

================== ENV ==================
load_dotenv(encoding="utf-8")

BOT_TOKEN = os.getenv("BOT_TOKEN")
CHANNEL_ID = os.getenv("CHANNEL_USERNAME", "@alexbullpogoda")
JOIN_URL = f"https://t.me/{CHANNEL_ID.lstrip('@')}"

DATA_FILE = "data.json"

================== RUNTIME STATE ==================
LAST_CITY: Dict[int, str] = {} # user_id -> last free-text
PICK_OPTIONS: Dict[int, List[Dict[str, Any]]] = {} # user_id -> geocoding options
STATE: Dict[str, Any] = {"users": {}} # persistent

================== HELP ==================
HELP_TEXT = (
"–ü—Ä–∏—à–ª–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≥–æ—Ä–æ–¥–∞ (–Ω–∞ —Ä—É—Å—Å–∫–æ–º –∏–ª–∏ –ª–∞—Ç–∏–Ω–∏—Ü–µ–π) ‚Äî –æ—Ç–≤–µ—á—É –ø—Ä–æ–≥–Ω–æ–∑–æ–º –Ω–∞ –∑–∞–≤—Ç—Ä–∞.\n\n"
"–ö–æ–º–∞–Ω–¥—ã:\n"
"- /start ‚Äî –Ω–∞—á–∞—Ç—å\n"
"- /help ‚Äî –ø–æ–º–æ—â—å\n"
"- /repeat ‚Äî –ø–æ–≤—Ç–æ—Ä–∏—Ç—å –ø—Ä–æ–≥–Ω–æ–∑ –ø–æ –ø–æ—Å–ª–µ–¥–Ω–µ–º—É –≥–æ—Ä–æ–¥—É\n"
"- /daily HH:MM ‚Äî –ø—Ä–∏—Å—ã–ª–∞—Ç—å –ø—Ä–æ–≥–Ω–æ–∑ –∫–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è (–≤–∞—à–µ–≥–æ –≥–æ—Ä–æ–¥–∞)\n"
"- /stop ‚Äî –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –µ–∂–µ–¥–Ω–µ–≤–Ω—É—é —Ä–∞—Å—Å—ã–ª–∫—É\n"
)

================== OPEN-METEO ==================
GEOCODE_URL = "https://geocoding-api.open-meteo.com/v1/search"
FORECAST_URL = "https://api.open-meteo.com/v1/forecast"

async def geocode_city(session: aiohttp.ClientSession, query: str, count: int = 5) -> List[Dict[str, Any]]:
params = {"name": query, "count": count, "language": "ru", "format": "json"}
async with session.get(GEOCODE_URL, params=params, timeout=15) as r:
if r.status != 200:
return []
data = await r.json()
return data.get("results") or []

async def fetch_tomorrow_forecast(session: aiohttp.ClientSession, lat: float, lon: float, tz: str) -> Optional[Dict[str, Any]]:
params = {
"latitude": lat, "longitude": lon, "timezone": tz,
"daily": [
"temperature_2m_max", "temperature_2m_min",
"precipitation_sum", "precipitation_probability_max",
"windspeed_10m_max", "winddirection_10m_dominant",
"weathercode", "sunrise", "sunset", "cloudcover_mean",
],
}
async with session.get(FORECAST_URL, params=params, timeout=15) as r:
if r.status != 200:
return None
data = await r.json()

text
daily = data.get("daily") or {}
dates = daily.get("time") or []
if not dates:
    return None

idx = 1 if len(dates) > 1 else 0

def pick(key, default=None):
    arr = daily.get(key)
    return arr[idx] if isinstance(arr, list) and len(arr) > idx else default

return {
    "date": dates[idx],
    "tmax": pick("temperature_2m_max"),
    "tmin": pick("temperature_2m_min"),
    "precip_mm": pick("precipitation_sum", 0),
    "precip_prob": pick("precipitation_probability_max"),
    "wind_max": pick("windspeed_10m_max"),
    "wind_dir": pick("winddirection_10m_dominant"),
    "weathercode": pick("weathercode"),
    "sunrise": pick("sunrise"),
    "sunset": pick("sunset"),
    "clouds": pick("cloudcover_mean"),
}
def wmo_to_emoji(wmo: Optional[int]) -> str:
if wmo is None:
return "üå§Ô∏è"
if wmo in (0,):
return "‚òÄÔ∏è"
if wmo in (1, 2):
return "üå§Ô∏è"
if wmo in (3,):
return "‚òÅÔ∏è"
if 45 <= wmo <= 48:
return "üå´Ô∏è"
if 51 <= wmo <= 67:
return "üå¶Ô∏è"
if 71 <= wmo <= 77:
return "üå®Ô∏è"
if 80 <= wmo <= 82:
return "üåßÔ∏è"
if 85 <= wmo <= 86:
return "‚ùÑÔ∏è"
if 95 <= wmo <= 99:
return "‚õàÔ∏è"
return "üå§Ô∏è"

def format_wind_dir_full(deg: Optional[float]) -> str:
if deg is None:
return "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö"
names = [
"–°–µ–≤–µ—Ä", "–°–µ–≤–µ—Ä–æ‚Äë—Å–µ–≤–µ—Ä–æ‚Äë–≤–æ—Å—Ç–æ–∫", "–°–µ–≤–µ—Ä–æ‚Äë–≤–æ—Å—Ç–æ–∫", "–í–æ—Å—Ç–æ–∫‚Äë—Å–µ–≤–µ—Ä–æ‚Äë–≤–æ—Å—Ç–æ–∫",
"–í–æ—Å—Ç–æ–∫", "–í–æ—Å—Ç–æ–∫‚Äë—é–≥–æ‚Äë–≤–æ—Å—Ç–æ–∫", "–Æ–≥–æ‚Äë–≤–æ—Å—Ç–æ–∫", "–Æ–≥–æ‚Äë—é–≥–æ‚Äë–≤–æ—Å—Ç–æ–∫",
"–Æ–≥", "–Æ–≥–æ‚Äë—é–≥–æ‚Äë–∑–∞–ø–∞–¥", "–Æ–≥–æ‚Äë–∑–∞–ø–∞–¥", "–ó–∞–ø–∞–¥‚Äë—é–≥–æ‚Äë–∑–∞–ø–∞–¥",
"–ó–∞–ø–∞–¥", "–ó–∞–ø–∞–¥‚Äë—Å–µ–≤–µ—Ä–æ‚Äë–∑–∞–ø–∞–¥", "–°–µ–≤–µ—Ä–æ‚Äë–∑–∞–ø–∞–¥", "–°–µ–≤–µ—Ä–æ‚Äë—Å–µ–≤–µ—Ä–æ‚Äë–∑–∞–ø–∞–¥"
]
i = int((deg % 360) / 22.5 + 0.5) % 16
return names[i]

def format_city_label(geo: Dict[str, Any]) -> str:
name = geo.get("name", "")
admin = geo.get("admin1") or ""
country = geo.get("country_code") or ""
label = f"{name}, {admin}, {country}".strip().strip(", ")
while ", ," in label:
label = label.replace(", ,", ",")
return label

def format_forecast_text(city_label: str, tz: str, f: Dict[str, Any]) -> str:
emoji = wmo_to_emoji(f["weathercode"])
wind_dir = format_wind_dir_full(f["wind_dir"])
precip = f["precip_mm"]
precip_line = f"–û—Å–∞–¥–∫–∏: {precip:.1f} –º–º" if precip is not None else "–û—Å–∞–¥–∫–∏: ‚Äî"
prob = f["precip_prob"]
prob_line = f"–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –æ—Å–∞–¥–∫–æ–≤: {prob}%" if prob is not None else "–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –æ—Å–∞–¥–∫–æ–≤: ‚Äî"
parts = [
f"{emoji} –ü—Ä–æ–≥–Ω–æ–∑ –Ω–∞ –∑–∞–≤—Ç—Ä–∞ –¥–ª—è {city_label} ({f['date']}).",
f"–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞: –æ—Ç {round(f['tmin'])}¬∞ –¥–æ {round(f['tmax'])}¬∞C",
f"–û–±–ª–∞—á–Ω–æ—Å—Ç—å: {f['clouds']}%" if f.get("clouds") is not None else "–û–±–ª–∞—á–Ω–æ—Å—Ç—å: ‚Äî",
precip_line,
prob_line,
f"–í–µ—Ç–µ—Ä: –¥–æ {round(f['wind_max'])} –º/—Å, –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: {wind_dir}" if f.get("wind_max") is not None else "–í–µ—Ç–µ—Ä: ‚Äî",
f"–í–æ—Å—Ö–æ–¥: {f['sunrise']} –ó–∞–∫–∞—Ç: {f['sunset']}",
]
return "\n".join(parts)

def load_state():
global STATE
if os.path.exists(DATA_FILE):
try:
with open(DATA_FILE, "r", encoding="utf-8") as f:
STATE = json.load(f)
except Exception:
STATE = {"users": {}}

def save_state():
tmp = DATA_FILE + ".tmp"
with open(tmp, "w", encoding="utf-8") as f:
json.dump(STATE, f, ensure_ascii=False, indent=2)
os.replace(tmp, DATA_FILE)

def ensure_user(user_id: int) -> Dict[str, Any]:
users = STATE.setdefault("users", {})
u = users.get(str(user_id))
if not u:
u = {}
users[str(user_id)] = u
return u

================== SUBSCRIPTION ==================
async def is_subscribed(bot: Bot, user_id: int) -> bool:
try:
member = await bot.get_chat_member(CHANNEL_ID, user_id)
return member.status in {
ChatMemberStatus.MEMBER,
ChatMemberStatus.ADMINISTRATOR,
ChatMemberStatus.OWNER,
}
except Exception:
return False

async def require_subscription(message: types.Message, bot: Bot) -> bool:
if await is_subscribed(bot, message.from_user.id):
return True
kb = InlineKeyboardBuilder()
kb.button(text="‚úÖ –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –∫–∞–Ω–∞–ª", url=JOIN_URL)
kb.button(text="üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data="check_sub")
kb.adjust(1)
await message.answer(
"–§—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –ø–æ–¥–ø–∏—Å—á–∏–∫–∞–º –∫–∞–Ω–∞–ª–∞.\n"
"1) –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª\n"
"2) –ù–∞–∂–º–∏ ¬´–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É¬ª üëá",
reply_markup=kb.as_markup()
)
return False

================== ACTIONS ==================
async def send_tomorrow_forecast(bot: Bot, user_id: int):
user = ensure_user(user_id)
if not user.get("lat"):
await bot.send_message(user_id, "–£ –≤–∞—Å –Ω–µ –≤—ã–±—Ä–∞–Ω –≥–æ—Ä–æ–¥. –ù–∞–ø–∏—à–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≥–æ—Ä–æ–¥–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ–º, –Ω–∞–ø—Ä–∏–º–µ—Ä: ¬´–ì—Ä–æ–¥–Ω–æ¬ª.")
return
lat = user["lat"]; lon = user["lon"]; tz = user["tz"]; label = user["city_label"]
async with aiohttp.ClientSession() as session:
fc = await fetch_tomorrow_forecast(session, lat, lon, tz)
if not fc:
await bot.send_message(user_id, "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–≥–Ω–æ–∑. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
return
text = format_forecast_text(label, tz, fc)
await bot.send_message(user_id, text, parse_mode=ParseMode.MARKDOWN)

def schedule_daily(scheduler: AsyncIOScheduler, bot: Bot, user_id: int, time_str: str, tz: str):
job_id = f"daily_{user_id}"
job = scheduler.get_job(job_id)
if job:
job.remove()
hour, minute = map(int, time_str.split(":"))
trigger = CronTrigger(hour=hour, minute=minute, timezone=pytz.timezone(tz))
scheduler.add_job(send_tomorrow_forecast, trigger, args=[bot, user_id], id=job_id, replace_existing=True)

def cancel_daily(scheduler: AsyncIOScheduler, user_id: int):
job_id = f"daily_{user_id}"
job = scheduler.get_job(job_id)
if job:
job.remove()

async def handle_city_query(message: types.Message, query: str):
user_id = message.from_user.id
LAST_CITY[user_id] = query
async with aiohttp.ClientSession() as session:
results = await geocode_city(session, query, count=5)
if not results:
await message.answer("–ù–µ –Ω–∞—à—ë–ª —Ç–∞–∫–æ–π –≥–æ—Ä–æ–¥. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ (–º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Å—Ç—Ä–∞–Ω—É: ¬´–ì—Ä–æ–¥–Ω–æ, BY¬ª).")
return
if len(results) == 1:
await apply_city_and_reply(message, results)
return
PICK_OPTIONS[user_id] = results
kb = InlineKeyboardBuilder()
for idx, geo in enumerate(results[:5]):
label = format_city_label(geo)
kb.button(text=label[:64], callback_data=f"pick:{idx}")
kb.adjust(1)
await message.answer("–£—Ç–æ—á–Ω–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≥–æ—Ä–æ–¥:", reply_markup=kb.as_markup())

async def apply_city_and_reply(message: types.Message, geo: Dict[str, Any]):
user_id = message.from_user.id
label = format_city_label(geo)
lat = float(geo["latitude"]); lon = float(geo["longitude"])
tz = geo.get("timezone", "auto")
user = ensure_user(user_id)
user.update({"city_label": label, "lat": lat, "lon": lon, "tz": tz})
save_state()
async with aiohttp.ClientSession() as session:
fc = await fetch_tomorrow_forecast(session, lat, lon, tz)
if not fc:
await message.answer("–ù–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–≥–Ω–æ–∑. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
return
text = format_forecast_text(label, tz, fc)
kb = InlineKeyboardBuilder()
kb.button(text="üîî –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–π –ø—Ä–æ–≥–Ω–æ–∑ (08:00)", callback_data="daily:08:00")
kb.adjust(1)
await message.answer(text, parse_mode=ParseMode.MARKDOWN, reply_markup=kb.as_markup())

================== WEBHOOK SERVER (aiohttp) ==================
from aiohttp import web
from aiogram.webhook.aiohttp_server import SimpleRequestHandler, setup_application

WEBHOOK_SECRET = os.getenv("WEBHOOK_SECRET", "secret123")
BASE_URL = os.getenv("BASE_URL") # –ø—Ä–∏–º–µ—Ä: https://alexbullpogoda.osc-fr1.scalingo.io
WEBHOOK_PATH = f"/webhook/{WEBHOOK_SECRET}"

async def on_startup(app: web.Application):
bot: Bot = app["bot"]
# –°—Ç–∞–≤–∏–º –≤–µ–±—Ö—É–∫ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ BASE_URL —É–∂–µ —É–∫–∞–∑–∞–Ω
if BASE_URL:
await bot.set_webhook(f"{BASE_URL}{WEBHOOK_PATH}")

async def on_shutdown(app: web.Application):
bot: Bot = app["bot"]
try:
await bot.delete_webhook(drop_pending_updates=True)
except Exception:
pass

def run_webhook(bot: Bot, dp: Dispatcher):
app = web.Application()
app["bot"] = bot
app.on_startup.append(on_startup)
app.on_shutdown.append(on_shutdown)

text
SimpleRequestHandler(dispatcher=dp, bot=bot).register(app, path=WEBHOOK_PATH)
setup_application(app, dp, bot=bot)

web.run_app(app, host="0.0.0.0", port=int(os.getenv("PORT", "10000")))
================== MAIN ==================
def main():
if not BOT_TOKEN:
raise RuntimeError("–£–∫–∞–∂–∏—Ç–µ BOT_TOKEN –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")

text
load_state()

bot = Bot(BOT_TOKEN)
dp = Dispatcher()

scheduler = AsyncIOScheduler(timezone=pytz.UTC)
scheduler.start()

@dp.message(CommandStart())
async def start(m: types.Message):
    if not await require_subscription(m, bot):
        return
    await m.answer(
        "–ü—Ä–∏–≤–µ—Ç! üëã –ù–∞–ø–∏—à–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≥–æ—Ä–æ–¥–∞ (–Ω–∞ —Ä—É—Å—Å–∫–æ–º —Ç–æ–∂–µ –º–æ–∂–Ω–æ) ‚Äî –ø—Ä–∏—à–ª—é –ø—Ä–æ–≥–Ω–æ–∑ –Ω–∞ –∑–∞–≤—Ç—Ä–∞.\n\n" + HELP_TEXT
    )

@dp.message(Command("help"))
async def help_cmd(m: types.Message):
    await m.answer(HELP_TEXT)

@dp.message(Command("repeat"))
async def repeat_cmd(m: types.Message):
    uid = m.from_user.id
    city = LAST_CITY.get(uid) or ensure_user(uid).get("city_label")
    if not city:
        await m.answer("–Ø –µ—â—ë –Ω–µ –∑–Ω–∞—é –≤–∞—à –≥–æ—Ä–æ–¥. –ü—Ä–∏—à–ª–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≥–æ—Ä–æ–¥–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ–º.")
        return
    user = ensure_user(uid)
    if user.get("lat"):
        class FakeMsg:
            from_user = m.from_user

            async def answer(self, text, **kwargs):
                await m.answer(text, **kwargs)

        geo = {
            "latitude": user["lat"],
            "longitude": user["lon"],
            "timezone": user["tz"],
            "name": user.get("city_label"),
        }
        await apply_city_and_reply(FakeMsg(), geo)
    else:
        await handle_city_query(m, city)

@dp.message(Command("daily"))
async def daily_cmd(m: types.Message):
    if not await require_subscription(m, bot):
        return
    parts = m.text.strip().split()
    if len(parts) != 2 or ":" not in parts:[1]
        await m.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /daily HH:MM\n–ù–∞–ø—Ä–∏–º–µ—Ä: /daily 08:30")
        return
    time_str = parts[1]
    uid = m.from_user.id
    user = ensure_user(uid)
    if not user.get("lat"):
        await m.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –≥–æ—Ä–æ–¥: –ø—Ä–∏—à–ª–∏—Ç–µ –µ–≥–æ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–µ–º.")
        return
    user["daily"] = {"time": time_str}
    save_state()
    schedule_daily(scheduler, bot, uid, time_str, user["tz"])
    await m.answer(f"–ì–æ—Ç–æ–≤–æ! –ë—É–¥—É –ø—Ä–∏—Å—ã–ª–∞—Ç—å –ø—Ä–æ–≥–Ω–æ–∑ –∫–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ {time_str} –ø–æ –≤–∞—à–µ–º—É –≤—Ä–µ–º–µ–Ω–∏ ({user['tz']}).")

@dp.message(Command("stop"))
async def stop_cmd(m: types.Message):
    uid = m.from_user.id
    cancel_daily(scheduler, uid)
    user = ensure_user(uid)
    user.pop("daily", None)
    save_state()
    await m.answer("–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞.")

@dp.callback_query(F.data == "check_sub")
async def check_sub(c: types.CallbackQuery):
    if await is_subscribed(bot, c.from_user.id):
        await c.message.answer("‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞! –¢–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≥–æ—Ä–æ–¥–∞.")
    else:
        await c.answer("–ù–µ –≤–∏–∂—É –ø–æ–¥–ø–∏—Å–∫—É. –ü–æ–¥–ø–∏—à–∏—Å—å –∏ –Ω–∞–∂–º–∏ —Å–Ω–æ–≤–∞.", show_alert=True)

@dp.callback_query(F.data.startswith("pick:"))
async def pick_city(c: types.CallbackQuery):
    uid = c.from_user.id
    opts = PICK_OPTIONS.get(uid) or []
    try:
        idx = int(c.data.split(":"))[1]
    except Exception:
        await c.answer("–û—à–∏–±–∫–∞ –≤—ã–±–æ—Ä–∞.", show_alert=True)
        return
    if idx < 0 or idx >= len(opts):
        await c.answer("–°–ª–∏—à–∫–æ–º —Å—Ç–∞—Ä—ã–π —Å–ø–∏—Å–æ–∫ ‚Äî –ø—Ä–∏—à–ª–∏—Ç–µ –≥–æ—Ä–æ–¥ –µ—â—ë —Ä–∞–∑.", show_alert=True)
        return
    geo = opts[idx]
    PICK_OPTIONS.pop(uid, None)
    await c.message.edit_text(f"–í—ã –≤—ã–±—Ä–∞–ª–∏: {format_city_label(geo)}")

    class FakeMsg:
        from_user = c.from_user

        async def answer(self, text, **kwargs):
            await c.message.answer(text, **kwargs)

    await apply_city_and_reply(FakeMsg(), geo)
    await c.answer()

@dp.callback_query(F.data.startswith("daily:"))
async def quick_daily(c: types.CallbackQuery):
    uid = c.from_user.id
    user = ensure_user(uid)
    if not user.get("lat"):
        await c.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –≥–æ—Ä–æ–¥.", show_alert=True)
        return
    _, t = c.data.split(":", 1)
    user["daily"] = {"time": t}
    save_state()
    schedule_daily(scheduler, bot, uid, t, user["tz"])
    await c.message.answer(f"–ü–æ–¥–ø–∏—Å–∞–ª! –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –ø—Ä–æ–≥–Ω–æ–∑ –≤ {t} –ø–æ –≤—Ä–µ–º–µ–Ω–∏ {user['tz']}.")
    await c.answer()

@dp.message(F.text)
async def any_text(m: types.Message):
    if not await require_subscription(m, bot):
        return
    await handle_city_query(m, m.text.strip())

# –ó–∞–ø—É—Å–∫ webhook-—Å–µ—Ä–≤–µ—Ä–∞
run_webhook(bot, dp)
if name == "main":
main()